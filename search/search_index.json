{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"eYFi-Mega based Spectrum Analyzer Mentor(s) : Sourav, Prasad Interns : Aravinda Harithsa, Marefat Abbas Introduction eYFi Mega based Spectrum Analyzer is an Audio device project where we will take the input signal from Microphone and display its frequency spectrum as output. In this project we will be using OLED display for Spectrum Display and an Amplifier Microphone for Signal. DEMO OF PROJECT eYFi Mega Development board eYFi Mega Development board is an Atmega2560 and ESP32 based development board, made in India. This board is developed by eYantra at IIT Bombay. Key-points: Atmega2560 and ESP32 based WiFi Compatible FreeRTOS Compatible Arduino IDE suitable What is a Spectrum Analyzer ? Spectrum Analyzer is an electronic device which measures the magnitude of an Input Signal (Audio Signal) versus Frequency within full frequency range of device. Used for analyzing waves in frequency domain. This Spectrum Analyzer device is used for Power applications. Digital Signal Processing (DSP) Mathematical manipulation of Digial Signals like Audio, Video, Pressure, Temperature, etc is called as Digital Signal Processing (DSP) . It is the use of digital processing, such as by computers or more specialized digital signal processors, to perform a wide variety of signal processing operations. DSP can involve linear or nonlinear operations. Nonlinear signal processing is closely related to nonlinear system identification and can be implemented in the time, frequency, and spatio-temporal domains. ESP32 based Spectrum Analyser Overview This project converts an analogue signal which is received from microphone module and displays its frequency components in the form of a spectrum of bands on an OLED display. To do this, it uses a Fast Fourier Transform (FFT) . Sampling theorem is a fundamental bridge between continuous-time signals (analogue signals) and discrete-time signals. It uses a sample rate that enables discrete sequences of samples to capture all the information from a continuous-time signal of finite bandwidth. ESP32 WROOM which is present on our development board can analyze analogue signals with a maximum fundamental frequency of 20,000Hz (20.0 KHz) with a sample size of 512 elements. This limit is determined by the Analogue to Digital Converter (ADC) speed which can convert at a rate of approximately 40 KHz.So for our application 0-20,000 hz was more than sufficient The system is comprised of the processor ESP32, an OLED display either 0.96\u2033 and a audio microphone MAX4466 unit that is comprised of an electret microphone and pre built tunable amplifier. The received audio is applied to the ADC input of the process. FFT Elements \u2013 Sample Size and Sampling frequency Sample Size \u2013 The FFT-algorithm defines a set of samples for the analysis results to be stored in. For most algorithms, the number of samples is usually a factor of 2, so 16, 32, 64, 128 or 256 are not unusual. The greater the number of samples the more time it takes to convert an analogue signal, but the greater the frequency resolution and discrimination will be. Sampling Frequency \u2013 Reference to the Nyquist-Shannon Sampling Theorem says sampling of an analogue signal needs to be at least twice the frequency of the signal being analyzed, this limits the maximum frequency to half of the sampling frequency. The diagram above illustrates a wave which is colored red in the time domain, which refers to a view of the waveform with respect to amplitude and time, it therefore shows how the waveform changes over time. This is then overlaid with a frequency domain plot showing a representation of the individual frequency components which are embedded into it and their phase relationships In a Fourier transform analysis converts the function\u2019s time-domain representation, shown in red, to the function\u2019s frequency-domain representation, shown in blue. The component frequencies and amplitudes are spread across the frequency spectrum chosen for analysis and are represented as peaks in the frequency domain. In our implementation of code , the Fast Fourier Transform (FFT) is used , which is an algorithm that computes discrete Fourier transforms of the sampled waveform thereby enabling the waveform to be changed from its original time domain to the frequency domain. The FFT rapidly computes such transformations by factorizing the result into a matrix., we have made use of ArudinoFFT library which contains various functions,filters and windows .This library is the heart of the code which does translation of input analog signal into frequency spectrum .This library is easy to use and produced best accurate output for this project. Prototype is configured to make 64 samples and does FFT with those samples. ArduinoFFT library can do FFT of samples between 16 to 512. In the code the result arrays of real and imaginary components are called: double vReal[SAMPLES]; double vImag[SAMPLES]; In the array vReal and vImag this contains what is called the complex number results separated into the mathematical parlance of Real (vReal) and Imaginary (vImag) components. The contents of the arrays vReal and vImag contain the coordinates in the complex number in what's called polar coordinates that refers to the distance of a point of origin z from the origin (O), and the angle subtended between the positive real axis (Re) and the line segment Oz in a counter-clockwise sense. This leads to the polar form of complex numbers. The absolute value (or modulus or magnitude) of a complex number is defined as z = x + jy where \u2018j\u2019 is an imaginary operator. Its amplitude is derived from z = sqrt(a2 + b2) In the code once the sampling of a waveform has been completed and the result captured in the array elements of vReal[] we can ignore the phase angle for the analysis ,so vImag[ ] array elements are always assigned to 0. Next the array vReal is analysed by the FFT function, as follows: FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD); here we will be selecting the relevant window function,Number of samples ,and the array values of vreal FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD); Here we will be applying the FFt core algorithm by passing the relevant information FFT.ComplexToMagnitude(vReal, vImag, SAMPLES); We will be converting the obtained complex results into Real magnitude which can be plotted to form the spectrum . Hence we have reached the last step of this process","title":"Home"},{"location":"#_1","text":"Mentor(s) : Sourav, Prasad Interns : Aravinda Harithsa, Marefat Abbas","title":""},{"location":"#introduction","text":"eYFi Mega based Spectrum Analyzer is an Audio device project where we will take the input signal from Microphone and display its frequency spectrum as output. In this project we will be using OLED display for Spectrum Display and an Amplifier Microphone for Signal. DEMO OF PROJECT","title":"Introduction"},{"location":"#eyfi-mega-development-board","text":"eYFi Mega Development board is an Atmega2560 and ESP32 based development board, made in India. This board is developed by eYantra at IIT Bombay. Key-points: Atmega2560 and ESP32 based WiFi Compatible FreeRTOS Compatible Arduino IDE suitable","title":"eYFi Mega Development board"},{"location":"#what-is-a-spectrum-analyzer","text":"Spectrum Analyzer is an electronic device which measures the magnitude of an Input Signal (Audio Signal) versus Frequency within full frequency range of device. Used for analyzing waves in frequency domain. This Spectrum Analyzer device is used for Power applications.","title":"What is a Spectrum Analyzer ?"},{"location":"#digital-signal-processing-dsp","text":"Mathematical manipulation of Digial Signals like Audio, Video, Pressure, Temperature, etc is called as Digital Signal Processing (DSP) . It is the use of digital processing, such as by computers or more specialized digital signal processors, to perform a wide variety of signal processing operations. DSP can involve linear or nonlinear operations. Nonlinear signal processing is closely related to nonlinear system identification and can be implemented in the time, frequency, and spatio-temporal domains.","title":"Digital Signal Processing (DSP)"},{"location":"#esp32-based-spectrum-analyser","text":"","title":"ESP32 based  Spectrum Analyser"},{"location":"#overview","text":"This project converts an analogue signal which is received from microphone module and displays its frequency components in the form of a spectrum of bands on an OLED display. To do this, it uses a Fast Fourier Transform (FFT) . Sampling theorem is a fundamental bridge between continuous-time signals (analogue signals) and discrete-time signals. It uses a sample rate that enables discrete sequences of samples to capture all the information from a continuous-time signal of finite bandwidth. ESP32 WROOM which is present on our development board can analyze analogue signals with a maximum fundamental frequency of 20,000Hz (20.0 KHz) with a sample size of 512 elements. This limit is determined by the Analogue to Digital Converter (ADC) speed which can convert at a rate of approximately 40 KHz.So for our application 0-20,000 hz was more than sufficient The system is comprised of the processor ESP32, an OLED display either 0.96\u2033 and a audio microphone MAX4466 unit that is comprised of an electret microphone and pre built tunable amplifier. The received audio is applied to the ADC input of the process.","title":"Overview"},{"location":"#fft-elements-sample-size-and-sampling-frequency","text":"Sample Size \u2013 The FFT-algorithm defines a set of samples for the analysis results to be stored in. For most algorithms, the number of samples is usually a factor of 2, so 16, 32, 64, 128 or 256 are not unusual. The greater the number of samples the more time it takes to convert an analogue signal, but the greater the frequency resolution and discrimination will be. Sampling Frequency \u2013 Reference to the Nyquist-Shannon Sampling Theorem says sampling of an analogue signal needs to be at least twice the frequency of the signal being analyzed, this limits the maximum frequency to half of the sampling frequency. The diagram above illustrates a wave which is colored red in the time domain, which refers to a view of the waveform with respect to amplitude and time, it therefore shows how the waveform changes over time. This is then overlaid with a frequency domain plot showing a representation of the individual frequency components which are embedded into it and their phase relationships In a Fourier transform analysis converts the function\u2019s time-domain representation, shown in red, to the function\u2019s frequency-domain representation, shown in blue. The component frequencies and amplitudes are spread across the frequency spectrum chosen for analysis and are represented as peaks in the frequency domain. In our implementation of code , the Fast Fourier Transform (FFT) is used , which is an algorithm that computes discrete Fourier transforms of the sampled waveform thereby enabling the waveform to be changed from its original time domain to the frequency domain. The FFT rapidly computes such transformations by factorizing the result into a matrix., we have made use of ArudinoFFT library which contains various functions,filters and windows .This library is the heart of the code which does translation of input analog signal into frequency spectrum .This library is easy to use and produced best accurate output for this project. Prototype is configured to make 64 samples and does FFT with those samples. ArduinoFFT library can do FFT of samples between 16 to 512. In the code the result arrays of real and imaginary components are called: double vReal[SAMPLES]; double vImag[SAMPLES]; In the array vReal and vImag this contains what is called the complex number results separated into the mathematical parlance of Real (vReal) and Imaginary (vImag) components. The contents of the arrays vReal and vImag contain the coordinates in the complex number in what's called polar coordinates that refers to the distance of a point of origin z from the origin (O), and the angle subtended between the positive real axis (Re) and the line segment Oz in a counter-clockwise sense. This leads to the polar form of complex numbers. The absolute value (or modulus or magnitude) of a complex number is defined as z = x + jy where \u2018j\u2019 is an imaginary operator. Its amplitude is derived from z = sqrt(a2 + b2) In the code once the sampling of a waveform has been completed and the result captured in the array elements of vReal[] we can ignore the phase angle for the analysis ,so vImag[ ] array elements are always assigned to 0. Next the array vReal is analysed by the FFT function, as follows: FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD); here we will be selecting the relevant window function,Number of samples ,and the array values of vreal FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD); Here we will be applying the FFt core algorithm by passing the relevant information FFT.ComplexToMagnitude(vReal, vImag, SAMPLES); We will be converting the obtained complex results into Real magnitude which can be plotted to form the spectrum . Hence we have reached the last step of this process","title":"FFT Elements \u2013 Sample Size and Sampling frequency"},{"location":"02_hardware/","text":"eYFi-Mega based Spectrum Analyzer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Circuit Schematic Components Used 1. eYFi Mega Development Board - ATmega2560 and ESP32 based development board Arduino Programming Language Compatible Wi-Fi compatible Over-The-Air Update Bluetooth Low Energy Compatible with FreeRTOS 2. 128x64 0.96 Inch OLED Display Module - Resolution: 128 x 64 Visual Angle: >160\u00b0 Input Voltage: 3.3V ~ 6V Compatible I/O Level: 3.3V, 5V Mini Size: 2.7 x 2.8cm Only Need 2 I/O Port Control Full Compatible with Arduino 3. Electret Microphone Amplifier MAX4466 Adjustable GY-MAX4466 - VCC Range : 2.4 to 5 VDC DC bias : VCC/2 (In perfectly quiet)","title":"Hardware"},{"location":"02_hardware/#eyfi-mega-based-spectrum-analyzer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Spectrum Analyzer"},{"location":"02_hardware/#circuit-schematic","text":"","title":"Circuit Schematic"},{"location":"02_hardware/#components-used","text":"","title":"Components Used"},{"location":"02_hardware/#1-eyfi-mega-development-board-","text":"ATmega2560 and ESP32 based development board Arduino Programming Language Compatible Wi-Fi compatible Over-The-Air Update Bluetooth Low Energy Compatible with FreeRTOS","title":"1. eYFi Mega Development Board -"},{"location":"02_hardware/#2-128x64-096-inch-oled-display-module-","text":"Resolution: 128 x 64 Visual Angle: >160\u00b0 Input Voltage: 3.3V ~ 6V Compatible I/O Level: 3.3V, 5V Mini Size: 2.7 x 2.8cm Only Need 2 I/O Port Control Full Compatible with Arduino","title":"2. 128x64 0.96 Inch OLED Display Module -"},{"location":"02_hardware/#3-electret-microphone-amplifier-max4466-adjustable-gy-max4466-","text":"VCC Range : 2.4 to 5 VDC DC bias : VCC/2 (In perfectly quiet)","title":"3. Electret Microphone Amplifier MAX4466 Adjustable GY-MAX4466 -"},{"location":"03_software/","text":"eYFi-Mega based Spectrum Analyzer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Softwares 1. Arduino IDE Open-source Arduino Software (IDE) Easy to write code and upload it to the board Runs on Windows, Mac OS X, and Linux Environment is written in Java Based on Processing and other open-source software.","title":"Software"},{"location":"03_software/#eyfi-mega-based-spectrum-analyzer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Spectrum Analyzer"},{"location":"03_software/#softwares","text":"","title":"Softwares"},{"location":"03_software/#1-arduino-ide","text":"Open-source Arduino Software (IDE) Easy to write code and upload it to the board Runs on Windows, Mac OS X, and Linux Environment is written in Java Based on Processing and other open-source software.","title":"1. Arduino IDE"},{"location":"04_code/","text":"eYFi-Mega based Spectrum Analyzer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Program Code For ATmega2560 /********************************************************* ********************************************************* * Program Name : atmega2560 * Project Name : eYFi-Mega based Spectrum Analyzer * Project Number : 12 * Author : Marefat Abbas, Aravinda Harithsa * Date : 24 June 2020 ********************************************************* *********************************************************/ #include <Keypad.h> const byte ROWS = 4; //four rows const byte COLS = 4; //three columns char keys[ROWS][COLS] = { {'1','2','3','A'}, {'4','5','6','B'}, {'7','8','9','C'}, {'*','0','#','D'} }; byte rowPins[ROWS] = {5,7,9,11}; //connect to the row pinouts of the keypad byte colPins[COLS] = {4,46,44,6}; //connect to the column pinouts of the keypad Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS ); byte ledPin = 13; boolean ledPin_state; void setup(){ Serial.begin(9600); Serial1.begin(9600); pinMode(ledPin, OUTPUT); // Sets the digital pin as output. digitalWrite(ledPin, HIGH); // Turn the LED on. ledPin_state = digitalRead(ledPin); // Store initial LED state. HIGH when LED is on. keypad.addEventListener(keypadEvent); // Add an event listener for this keypad } void loop(){ char key = keypad.getKey(); if (key) { Serial1.write(key); Serial.println(key); } } // Taking care of some special events. void keypadEvent(KeypadEvent key){ switch (keypad.getkey()){ case PRESSED: { if (key == '#') { digitalWrite(ledPin,!digitalRead(ledPin)); ledPin_state = digitalRead(ledPin); // Remember LED state, lit or unlit. } break; } } For ESP32 /********************************************************* ********************************************************* * Program Name : esp32 * Project Name : eYFi-Mega based Spectrum Analyzers * Project Number : 12 * Author : Marefat Abbas, Aravinda Harithsa * Date : 24 June 2020 ********************************************************* *********************************************************/ // Header #include <Wire.h> #include \"arduinoFFT.h\" #include \"SSD1306.h\" SSD1306 display(0x3c,SDA,SCL); #define SAMPLES 512 #define SAMPLING_FREQUENCY 40000 #define amplitude 150 #include <Tone32.h> #include \"SoundData.h\" #include \"XT_DAC_Audio.h\" #define Num_Samples 112 // number of dample of signal #define MaxWaveTypes 4 // types of wave (signal) int count1 = 0; int8_t PROGMEM TwinkleTwinkle[] = { NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_4, NOTE_SILENCE,BEAT_5,SCORE_END }; XT_DAC_Audio_Class DacAudio(25,0); //Create main player class object. Use GPIO 25, one of the 2 DAC pins and timer0 XT_Wav_Class Zero(sa); XT_Wav_Class One(re); XT_Wav_Class Two(ga); XT_Wav_Class Three(ma); XT_Wav_Class Four(pa); XT_Wav_Class Five(da); XT_Wav_Class Six(nee); XT_Wav_Class Seven(bsa); XT_Wav_Class Eight(EightWav); XT_Wav_Class Nine(NineWav); XT_Sequence_Class Sequence; // The sequence object, you add your sounds above to this object (see setup below) // Creation of FFT object for arudino arduinoFFT FFT = arduinoFFT(); unsigned int sampling_period_us; unsigned long microseconds; byte peak[] = {0,0,0,0,0,0,0}; double vReal[SAMPLES]; double vImag[SAMPLES]; unsigned long newTime, oldTime; void TaskBlink( void *pvParameters ); void TaskAnalogReadA3( void *pvParameters ); void displayBand(int band, int dsize){ int dmax = 50; if (dsize > dmax) dsize = dmax; if (band == 7) display.drawHorizontalLine(18*6,0, 14); for (int s = 0; s <= dsize; s=s+2){display.drawHorizontalLine(18*band,64-s, 14);} if (dsize > peak[band]) {peak[band] = dsize;} } void PlayNumber(char const *Number) { int NumChars=strlen(Number); // could lose this line of put strlen in loop below, but bad form to do so Sequence.RemoveAllPlayItems(); // Clear out any previous playlist for(int i=0;i<NumChars;i++) AddNumberToSequence(Number[i]); // For each number add in the sound for that number to the sequence DacAudio.Play(&Sequence); // Play the sequence, will not wait here to complete, works independently of your code Serial.println(Number); // Confirm number entered to the user over the serial } void AddNumberToSequence(char TheNumber) { // Adds in the wav for the single 0-9 number passed in as a char switch(TheNumber) { case '0' : Sequence.AddPlayItem(&Zero);break; case '1' : Sequence.AddPlayItem(&One);break; case '2' : Sequence.AddPlayItem(&Two);break; case '3' : Sequence.AddPlayItem(&Three);break; case '4' : Sequence.AddPlayItem(&Four);break; case '5' : Sequence.AddPlayItem(&Five);break; case '6' : Sequence.AddPlayItem(&Six);break; case '7' : Sequence.AddPlayItem(&Seven);break; case '8' : Sequence.AddPlayItem(&Eight);break; case '9' : Sequence.AddPlayItem(&Nine);break; } } void setup() { // initialize serial communication at 115200 bits per second: Serial.begin(115200); Serial2.begin(9600, SERIAL_8N1,16, 17); Wire.begin(5,4); // SDA, SCL display.init(); display.setFont(ArialMT_Plain_10); display.flipScreenVertically(); // Adjust to suit or remove sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQUENCY)); // Now set up two tasks to run independently. xTaskCreatePinnedToCore( TaskBlink , \"TaskBlink\" // Name of this particular task given for understanding , 1024 // This stack size can be checked & adjusted by reading the Stack Highwater , NULL , 1 // Priority , NULL , 0); xTaskCreatePinnedToCore( TaskAnalogReadA3 , \"AnalogReadA3\" , 1024 // Stack size , NULL , 2 // Priority , NULL , 1); // here select the core to which this task will be pinned // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started. } void loop() { // Empty. Things are done in Tasks. } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running Serial monitor and Audio synthesizer--------------------------------------*/ /*-----------------------------------------------------------------------------------------------------------------*/ void TaskBlink(void *pvParameters) // This is a task. { (void) pvParameters; XT_DAC_Audio_Class DacAudio(25,0); // Create the main player class object. Use GPIO 25 (DAC pin) and timer 0 for (;;) { DacAudio.FillBuffer(); if(Serial.available()) PlayNumber(Serial.readString().c_str()); vTaskDelay(10); } } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running DSP algorithm for FFT generation and Running audio Synthesizer---------------------*/ /*------------------------------------------------------------------------------------------------------------------*/ void TaskAnalogReadA3(void *pvParameters) // This is a task for spectrum analyzer { (void) pvParameters; for (;;) { Serial.println(\"SPECTRUM\"); display.clear(); display.drawString(0,0,\"0.1 0.2 0.5 1K 2K 4K 8K\"); for (int i = 0; i < SAMPLES; i++) { newTime = micros()-oldTime; oldTime = newTime; vReal[i] = analogRead(A0); // A conversion takes about 1uS on an ESP32 vImag[i] = 0; while (micros() < (newTime + sampling_period_us)) { /* do nothing to wait */ } } FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD); FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD); FFT.ComplexToMagnitude(vReal, vImag, SAMPLES); for (int i = 2; i < (SAMPLES/2); i++){ // Don't use sample 0 and only first SAMPLES/2 are usable. Each array eleement represents a frequency and its value the amplitude. if (vReal[i] > 2000) { // Add a crude noise filter, 10 x amplitude or more if (i<=2 ) displayBand(0,(int)vReal[i]/amplitude); // 125Hz if (i >3 && i<=5 ) displayBand(1,(int)vReal[i]/amplitude); // 250Hz if (i >5 && i<=7 ) displayBand(2,(int)vReal[i]/amplitude); // 500Hz if (i >7 && i<=15 ) displayBand(3,(int)vReal[i]/amplitude); // 1000Hz if (i >15 && i<=30 ) displayBand(4,(int)vReal[i]/amplitude); // 2000Hz if (i >30 && i<=53 ) displayBand(5,(int)vReal[i]/amplitude); // 4000Hz if (i >53 && i<=200 ) displayBand(6,(int)vReal[i]/amplitude); // 8000Hz if (i >200 ) displayBand(7,(int)vReal[i]/amplitude); // 16000Hz } for (byte band = 0; band <= 6; band++) display.drawHorizontalLine(18*band,64-peak[band],14); } if (millis()%4 == 0) {for (byte band = 0; band <= 6; band++) {if (peak[band] > 0) peak[band] -= 1;}} // Decay the peak display.display(); vTaskDelay(10); } }","title":"04 code"},{"location":"04_code/#eyfi-mega-based-spectrum-analyzer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Spectrum Analyzer"},{"location":"04_code/#program-code","text":"","title":"Program Code"},{"location":"04_code/#for-atmega2560","text":"/********************************************************* ********************************************************* * Program Name : atmega2560 * Project Name : eYFi-Mega based Spectrum Analyzer * Project Number : 12 * Author : Marefat Abbas, Aravinda Harithsa * Date : 24 June 2020 ********************************************************* *********************************************************/ #include <Keypad.h> const byte ROWS = 4; //four rows const byte COLS = 4; //three columns char keys[ROWS][COLS] = { {'1','2','3','A'}, {'4','5','6','B'}, {'7','8','9','C'}, {'*','0','#','D'} }; byte rowPins[ROWS] = {5,7,9,11}; //connect to the row pinouts of the keypad byte colPins[COLS] = {4,46,44,6}; //connect to the column pinouts of the keypad Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS ); byte ledPin = 13; boolean ledPin_state; void setup(){ Serial.begin(9600); Serial1.begin(9600); pinMode(ledPin, OUTPUT); // Sets the digital pin as output. digitalWrite(ledPin, HIGH); // Turn the LED on. ledPin_state = digitalRead(ledPin); // Store initial LED state. HIGH when LED is on. keypad.addEventListener(keypadEvent); // Add an event listener for this keypad } void loop(){ char key = keypad.getKey(); if (key) { Serial1.write(key); Serial.println(key); } } // Taking care of some special events. void keypadEvent(KeypadEvent key){ switch (keypad.getkey()){ case PRESSED: { if (key == '#') { digitalWrite(ledPin,!digitalRead(ledPin)); ledPin_state = digitalRead(ledPin); // Remember LED state, lit or unlit. } break; } }","title":"For ATmega2560"},{"location":"04_code/#for-esp32","text":"/********************************************************* ********************************************************* * Program Name : esp32 * Project Name : eYFi-Mega based Spectrum Analyzers * Project Number : 12 * Author : Marefat Abbas, Aravinda Harithsa * Date : 24 June 2020 ********************************************************* *********************************************************/ // Header #include <Wire.h> #include \"arduinoFFT.h\" #include \"SSD1306.h\" SSD1306 display(0x3c,SDA,SCL); #define SAMPLES 512 #define SAMPLING_FREQUENCY 40000 #define amplitude 150 #include <Tone32.h> #include \"SoundData.h\" #include \"XT_DAC_Audio.h\" #define Num_Samples 112 // number of dample of signal #define MaxWaveTypes 4 // types of wave (signal) int count1 = 0; int8_t PROGMEM TwinkleTwinkle[] = { NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_4, NOTE_SILENCE,BEAT_5,SCORE_END }; XT_DAC_Audio_Class DacAudio(25,0); //Create main player class object. Use GPIO 25, one of the 2 DAC pins and timer0 XT_Wav_Class Zero(sa); XT_Wav_Class One(re); XT_Wav_Class Two(ga); XT_Wav_Class Three(ma); XT_Wav_Class Four(pa); XT_Wav_Class Five(da); XT_Wav_Class Six(nee); XT_Wav_Class Seven(bsa); XT_Wav_Class Eight(EightWav); XT_Wav_Class Nine(NineWav); XT_Sequence_Class Sequence; // The sequence object, you add your sounds above to this object (see setup below) // Creation of FFT object for arudino arduinoFFT FFT = arduinoFFT(); unsigned int sampling_period_us; unsigned long microseconds; byte peak[] = {0,0,0,0,0,0,0}; double vReal[SAMPLES]; double vImag[SAMPLES]; unsigned long newTime, oldTime; void TaskBlink( void *pvParameters ); void TaskAnalogReadA3( void *pvParameters ); void displayBand(int band, int dsize){ int dmax = 50; if (dsize > dmax) dsize = dmax; if (band == 7) display.drawHorizontalLine(18*6,0, 14); for (int s = 0; s <= dsize; s=s+2){display.drawHorizontalLine(18*band,64-s, 14);} if (dsize > peak[band]) {peak[band] = dsize;} } void PlayNumber(char const *Number) { int NumChars=strlen(Number); // could lose this line of put strlen in loop below, but bad form to do so Sequence.RemoveAllPlayItems(); // Clear out any previous playlist for(int i=0;i<NumChars;i++) AddNumberToSequence(Number[i]); // For each number add in the sound for that number to the sequence DacAudio.Play(&Sequence); // Play the sequence, will not wait here to complete, works independently of your code Serial.println(Number); // Confirm number entered to the user over the serial } void AddNumberToSequence(char TheNumber) { // Adds in the wav for the single 0-9 number passed in as a char switch(TheNumber) { case '0' : Sequence.AddPlayItem(&Zero);break; case '1' : Sequence.AddPlayItem(&One);break; case '2' : Sequence.AddPlayItem(&Two);break; case '3' : Sequence.AddPlayItem(&Three);break; case '4' : Sequence.AddPlayItem(&Four);break; case '5' : Sequence.AddPlayItem(&Five);break; case '6' : Sequence.AddPlayItem(&Six);break; case '7' : Sequence.AddPlayItem(&Seven);break; case '8' : Sequence.AddPlayItem(&Eight);break; case '9' : Sequence.AddPlayItem(&Nine);break; } } void setup() { // initialize serial communication at 115200 bits per second: Serial.begin(115200); Serial2.begin(9600, SERIAL_8N1,16, 17); Wire.begin(5,4); // SDA, SCL display.init(); display.setFont(ArialMT_Plain_10); display.flipScreenVertically(); // Adjust to suit or remove sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQUENCY)); // Now set up two tasks to run independently. xTaskCreatePinnedToCore( TaskBlink , \"TaskBlink\" // Name of this particular task given for understanding , 1024 // This stack size can be checked & adjusted by reading the Stack Highwater , NULL , 1 // Priority , NULL , 0); xTaskCreatePinnedToCore( TaskAnalogReadA3 , \"AnalogReadA3\" , 1024 // Stack size , NULL , 2 // Priority , NULL , 1); // here select the core to which this task will be pinned // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started. } void loop() { // Empty. Things are done in Tasks. } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running Serial monitor and Audio synthesizer--------------------------------------*/ /*-----------------------------------------------------------------------------------------------------------------*/ void TaskBlink(void *pvParameters) // This is a task. { (void) pvParameters; XT_DAC_Audio_Class DacAudio(25,0); // Create the main player class object. Use GPIO 25 (DAC pin) and timer 0 for (;;) { DacAudio.FillBuffer(); if(Serial.available()) PlayNumber(Serial.readString().c_str()); vTaskDelay(10); } } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running DSP algorithm for FFT generation and Running audio Synthesizer---------------------*/ /*------------------------------------------------------------------------------------------------------------------*/ void TaskAnalogReadA3(void *pvParameters) // This is a task for spectrum analyzer { (void) pvParameters; for (;;) { Serial.println(\"SPECTRUM\"); display.clear(); display.drawString(0,0,\"0.1 0.2 0.5 1K 2K 4K 8K\"); for (int i = 0; i < SAMPLES; i++) { newTime = micros()-oldTime; oldTime = newTime; vReal[i] = analogRead(A0); // A conversion takes about 1uS on an ESP32 vImag[i] = 0; while (micros() < (newTime + sampling_period_us)) { /* do nothing to wait */ } } FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD); FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD); FFT.ComplexToMagnitude(vReal, vImag, SAMPLES); for (int i = 2; i < (SAMPLES/2); i++){ // Don't use sample 0 and only first SAMPLES/2 are usable. Each array eleement represents a frequency and its value the amplitude. if (vReal[i] > 2000) { // Add a crude noise filter, 10 x amplitude or more if (i<=2 ) displayBand(0,(int)vReal[i]/amplitude); // 125Hz if (i >3 && i<=5 ) displayBand(1,(int)vReal[i]/amplitude); // 250Hz if (i >5 && i<=7 ) displayBand(2,(int)vReal[i]/amplitude); // 500Hz if (i >7 && i<=15 ) displayBand(3,(int)vReal[i]/amplitude); // 1000Hz if (i >15 && i<=30 ) displayBand(4,(int)vReal[i]/amplitude); // 2000Hz if (i >30 && i<=53 ) displayBand(5,(int)vReal[i]/amplitude); // 4000Hz if (i >53 && i<=200 ) displayBand(6,(int)vReal[i]/amplitude); // 8000Hz if (i >200 ) displayBand(7,(int)vReal[i]/amplitude); // 16000Hz } for (byte band = 0; band <= 6; band++) display.drawHorizontalLine(18*band,64-peak[band],14); } if (millis()%4 == 0) {for (byte band = 0; band <= 6; band++) {if (peak[band] > 0) peak[band] -= 1;}} // Decay the peak display.display(); vTaskDelay(10); } }","title":"For ESP32"},{"location":"_index/","text":"eYFi-Mega based Spectrum Analyzer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Abstract The objective of this project is to develop an Spectrum Analyzer using eYFi-Mega development board with the help of ESP-DSP Library. Spectrum Analyzer Spectrum Analyzer is an electronic device which measures the magnitude of an Input Signal (Audio Signal) versus Frequency within full frequency range of device. Used for analyzing waves in frequency domain. This Spectrum Analyzer device is used for Power applications.","title":"**eYFi-Mega based Spectrum Analyzer**"},{"location":"_index/#eyfi-mega-based-spectrum-analyzer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Spectrum Analyzer"},{"location":"_index/#abstract","text":"The objective of this project is to develop an Spectrum Analyzer using eYFi-Mega development board with the help of ESP-DSP Library.","title":"Abstract"},{"location":"_index/#spectrum-analyzer","text":"Spectrum Analyzer is an electronic device which measures the magnitude of an Input Signal (Audio Signal) versus Frequency within full frequency range of device. Used for analyzing waves in frequency domain. This Spectrum Analyzer device is used for Power applications.","title":"Spectrum Analyzer"}]}